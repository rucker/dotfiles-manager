#!/usr/bin/python

import io
import os

import env
import ioutils
from constants import Systems, BashInputFiles, BashOutputFiles

def createHeadBuffer(fileName):
  buffer = io.StringIO()
  buffer.write(u"#!/bin/bash\n# ~/" + fileName + ": executed by bash(1) for non-login shells.\n# This file was generated by a script. Do not edit manually!\n\n")
  return buffer

def createScriptsDirBuffer():
  buffer = io.StringIO()
  buffer.write(u"__sourceInDir \"" + env.scriptsDir + "sourced/\"\n")
  buffer.write(u"__sourceInDir \"" + env.scriptsDir + "sourced-private/\"\n")
  return buffer

def compileBashFile(platform):
  if platform == Systems.DARWIN.value:
    bashFile = BashOutputFiles.BASH_PROFILE.value
    bashDotFile = BashOutputFiles.DOT_BASH_PROFILE.value
    bashPlatformFile = BashInputFiles.BASH_MAC.value
  elif platform == Systems.LINUX.value:
    bashFile = BashOutputFiles.BASHRC.value
    bashDotFile = BashOutputFiles.DOT_BASHRC.value
    bashPlatformFile = BashInputFiles.BASH_LINUX.value

  ioutils.handleExistingFile(env.homeDir + bashDotFile)
  print "Compiling file: " + bashFile
  fileBuffer = io.StringIO()
  map = dict()
  head = createHeadBuffer(bashDotFile)
  ioutils.mapInputFileContents(BashInputFiles.BASH_COMMON.value, map)
  ioutils.mapInputFileContents(bashPlatformFile, map)
  tail = createScriptsDirBuffer()
  ioutils.writeOutputFile(env.outputFilesDir + bashFile, head, ioutils.dictToBuffer(map), tail)
  if env.platform == platform:
    ioutils.mapOptionalInputFileContents(BashInputFiles.BASH_PRIVATE.value, map)
    ioutils.writeOutputFile(env.homeDir + bashDotFile, head, ioutils.dictToBuffer(map), tail)
  print "File completed.\n"

def compileBashProfile():
  compileBashFile(Systems.DARWIN.value)
def compileBashrc():
  compileBashFile(Systems.LINUX.value)

def compileBashFiles():
  compileBashProfile()
  compileBashrc()
